#!/usr/bin/env python
"""Silo level editor.

Usage: editor <level>

Options:
    -h --help   Show this screen.
    --version   Show version.
"""

import collections
import curses
import heapq
import sys

import dill
import docopt

APPLICATION_TITLE = "SILO LEVEL EDITOR"
CURSOR = "X"

COLOR_WHITE = 0
COLOR_RED = 1
COLOR_GREEN = 2
COLOR_BLUE = 3
COLOR_BLACK_ON_WHITE = 4

WINDOW_MAIN_OFFSET_X = 4
WINDOW_MAIN_OFFSET_Y = 6
WINDOW_MAIN_X = 2
WINDOW_MAIN_Y = 3
WINDOW_SELECT_HEIGHT = 6
WINDOW_SELECT_WIDTH = 20
WINDOW_STATUS_WIDTH = 17

KEYS = {
    'A': ('append', True),
    'I': ('insert', True),
    'Q': ('quit', ),
    'S': ('save', ),
    'X': ('remove_mode', ),
    'a': ('append', False),
    'h': ('move_cursor', 0, -1),
    'i': ('insert', False),
    'j': ('move_cursor', 1, 0),
    'k': ('move_cursor', -1, 0),
    'l': ('move_cursor', 0, 1),
    'x': ('remove', ),
    }

TILE_TYPES = {
    'door': '+',
    'floor': '.',
    'wall': '#',

    'one': '1',
    'two': '2',
    'three': '3',
    'four': '4',
    'five': '5',
    'six': '6',
    'seven': '7',
    'eight': '8',
    'nine': '9',
    'zero': '0',
    }

TILE_TYPE_SELECT = collections.OrderedDict(sorted(zip(TILE_TYPES.keys(),
        ["{} {}".format(char, name) for name, char in TILE_TYPES.items()])))


class WindowManager(object):
    """Manages refreshing windows, bottom to top."""

    def __init__(self, stdscr, container_window, main_window, status_window):
        self.stdscr = stdscr
        self.container_window = container_window
        self.main_window = main_window
        self.status_window = status_window
        self.windows = [stdscr, container_window, main_window, status_window]

        self.is_recompose_main = False
        self._redraw_queue = []

    def queue_redraw(self, window):
        """Add a window to redraw queue."""
        heapq.heappush(self._redraw_queue, (self.windows.index(window), window))

    def redraw_all(self):
        """Redraw all windows, bottom to top."""
        for window in self.windows:
            window.noutrefresh()
        curses.doupdate()

    def redraw_queued(self):
        """Redraw previously queued windows, bottom to top."""
        while self._redraw_queue:
            _, window = heapq.heappop(self._redraw_queue)
            window.noutrefresh()
        self._redraw_queue = []
        curses.doupdate()


class Tile(object):

    def __init__(self, tile_type):
        self.char = TILE_TYPES[tile_type]


def item_selection_prompt(window_manager, items):
    """Pops up a prompt which allows to select from a list of items.

    Args:
        window_manager -- WindowManager instance.
        items -- collections.OrderedDict, keys are to be returned,
                 values are to be displayed.

    Returns:
        None if window was dismissed, or key from `items` parameter
        for the selected item.

    Allows user to move with `j` and `k` keys, Enter to select, Escape
    or `Q`/`q` to quit.
    """
    current_line = 0
    dy = 0
    selected_item = None

    select_window_container = window_manager.main_window.subwin(
            WINDOW_SELECT_HEIGHT + 2,
            WINDOW_SELECT_WIDTH + 2,
            curses.LINES / 2 - WINDOW_SELECT_HEIGHT / 2 - 1,
            curses.COLS / 2 - WINDOW_SELECT_WIDTH / 2 - 1)
    select_window_container.box()
    select_window = select_window_container.subwin(
            WINDOW_SELECT_HEIGHT,
            WINDOW_SELECT_WIDTH,
            curses.LINES / 2 - WINDOW_SELECT_HEIGHT / 2,
            curses.COLS / 2 - WINDOW_SELECT_WIDTH / 2)
    window_manager.windows.append(select_window_container)
    window_manager.windows.append(select_window)
    window_manager.queue_redraw(select_window_container)

    while selected_item is None:
        select_window.clear()

        sublist = items.values()
        if len(items) > WINDOW_SELECT_HEIGHT:
            sublist = sublist[dy:WINDOW_SELECT_HEIGHT + dy]
            if dy == 0:
                sublist.pop()
                sublist.append('...')
            elif dy + WINDOW_SELECT_HEIGHT == len(items):
                sublist.pop(0)
                sublist.insert(0, '...')
            else:
                sublist.pop(0)
                sublist.pop()
                sublist.insert(0, '...')
                sublist.append('...')

        for i, value in enumerate(sublist):
            color = COLOR_BLACK_ON_WHITE \
                    if i == current_line - dy else COLOR_WHITE
            select_window.addstr(i, 0, value, curses.color_pair(color))

        window_manager.queue_redraw(select_window)
        window_manager.redraw_queued()

        ch = select_window.getch()
        if chr(ch) == 'j':
            if current_line == len(items) - 1:
                continue

            current_line += 1
            if dy + WINDOW_SELECT_HEIGHT <= current_line + 1 \
                    and dy + WINDOW_SELECT_HEIGHT != len(items):
                dy += 1
        elif chr(ch) == 'k':
            if current_line == 0:
                continue

            current_line -= 1
            if dy >= current_line and dy != 0:
                dy -= 1
        elif ch == 10:
            selected_item = items.keys()[current_line]
        elif chr(ch).lower() == 'q' or ch == 27:
            break

    window_manager.is_recompose_main = True
    window_manager.windows.pop()
    window_manager.windows.pop()

    return selected_item


class GlobalStateManager(object):
    """Manages variables and methods which must be global.

    See all the state variables in `__init__`. Important part here is
    all the `exec_*` methods, which are called dynamically from
    `main` using `KEYS` dict. Each `exec_*` method corresponds to a
    keystroke and performs some operations on the global state
    variables inside the class.
    """

    def __init__(self, window_manager, scene, save_file):
        self.save_file = save_file
        self.scene = scene
        self.window_manager = window_manager
        cursor_y, cursor_x = window_manager.main_window.getmaxyx()
        self.cursor_y, self.cursor_x = cursor_y / 2, cursor_x / 2

        self.current_tile = None
        self.is_append_mode = False
        self.is_remove_mode = False

    def _set_append_mode(self):
        self.is_append_mode = True
        self.is_remove_mode = False

    def _set_remove_mode(self):
        self.is_append_mode = False
        self.is_remove_mode = True

    def _reset_modes(self):
        self.is_append_mode = False
        self.is_remove_mode = False

    def recompose_main_window(self):
        """Draw objects in the scene and queue the main window redraw."""
        main_window = self.window_manager.main_window
        main_window.clear()

        for y in self.scene:
            for x in self.scene[y]:
                color = COLOR_BLACK_ON_WHITE \
                        if len(self.scene[y][x]) > 1 else COLOR_WHITE
                main_window.addstr(y, x, self.scene[y][x][-1].char,
                                   curses.color_pair(color))
        if self.is_remove_mode:
            cursor_color = COLOR_RED
        elif self.is_append_mode:
            cursor_color = COLOR_GREEN
        else:
            cursor_color = COLOR_BLUE
        main_window.addstr(self.cursor_y, self.cursor_x, CURSOR,
                           curses.color_pair(cursor_color))
        self.window_manager.queue_redraw(main_window)
        self.window_manager.is_recompose_main = False


    def exec_append(self, force_select):
        """Enter a mode to continuously add objects under cursor.

        Args:
            force_select -- Show tile select window even if
            `self.current_tile` is set.
        """
        enable_append_mode = not self.is_append_mode

        if enable_append_mode:
            if self.current_tile is None or force_select:
                tile_name = item_selection_prompt(
                        self.window_manager, TILE_TYPE_SELECT)
                if tile_name is None:
                    return
                self.current_tile = tile_name
            else:
                tile_name = self.current_tile

            self.scene[self.cursor_y][self.cursor_x].append(
                    Tile(self.current_tile))
            self._set_append_mode()

        else:
            self._reset_modes()

        status_window = self.window_manager.status_window
        status_window.clear()
        if enable_append_mode:
            status_window.addstr(0, 0, "-- APPEND --")

        self.window_manager.queue_redraw(status_window)
        self.window_manager.is_recompose_main = True

    def exec_insert(self, force_select):
        """Insert an object under cursor, prompt for tile if needed.

        Args:
            force_select -- Show tile select window even if
            `self.current_tile` is set.
        """
        if self.current_tile is None or force_select:
            tile_name = item_selection_prompt(
                    self.window_manager, TILE_TYPE_SELECT)
        else:
            tile_name = self.current_tile

        if tile_name is not None:
            self.current_tile = tile_name
            self.scene[self.cursor_y][self.cursor_x].append(
                    Tile(self.current_tile))

    def exec_move_cursor(self, dy, dx):
        """Move cursor; add or remove objects based on current mode."""
        self.cursor_y += dy
        self.cursor_x += dx
        self.window_manager.is_recompose_main = True

        if self.is_append_mode:
            self.scene[self.cursor_y][self.cursor_x].append(Tile(
                self.current_tile))

        if self.is_remove_mode:
            try:
                self.scene[self.cursor_y][self.cursor_x].pop()
            except IndexError:
                pass
            if not self.scene[self.cursor_y][self.cursor_x]:
                del self.scene[self.cursor_y][self.cursor_x]

    def exec_remove(self):
        """Remove an object under cursor."""
        try:
            self.scene[self.cursor_y][self.cursor_x].pop()
        except IndexError:
            pass
        if not self.scene[self.cursor_y][self.cursor_x]:
            del self.scene[self.cursor_y][self.cursor_x]

    def exec_remove_mode(self):
        """Enter a remove mode; remove topmost objects while moving."""
        enable_remove_mode = not self.is_remove_mode

        if enable_remove_mode:
            try:
                self.scene[self.cursor_y][self.cursor_x].pop()
            except IndexError:
                pass
            if not self.scene[self.cursor_y][self.cursor_x]:
                del self.scene[self.cursor_y][self.cursor_x]
            self._set_remove_mode()
        else:
            self._reset_modes()

        status_window = self.window_manager.status_window
        status_window.clear()
        if enable_remove_mode:
            status_window.addstr(0, 0, "-- REMOVE --")
        self.window_manager.queue_redraw(status_window)
        self.window_manager.is_recompose_main = True

    def exec_quit(self):
        """Exit the application."""
        sys.exit(0)

    def exec_save(self):
        """Save current level."""
        with open(self.save_file, 'w') as save_file:
            dill.dump(self.scene, save_file)


def init_colors():
    """Initialize curses color pairs, see constants up top."""
    if curses.has_colors():
        curses.start_color()

    curses.init_pair(COLOR_RED, curses.COLOR_RED, curses.COLOR_BLACK)
    curses.init_pair(COLOR_GREEN, curses.COLOR_GREEN, curses.COLOR_BLACK)
    curses.init_pair(COLOR_BLUE, curses.COLOR_BLUE, curses.COLOR_BLACK)
    curses.init_pair(COLOR_BLACK_ON_WHITE, curses.COLOR_BLACK,
                     curses.COLOR_WHITE)


def create_windows(stdscr, save_file):
    """Create all necessary windows to start the application.

    Args:
        stdscr -- curses.stdscr.
        save_file -- file name for the current edited file

    Returns:
        WindowManager instance.
    """
    stdscr.addstr(
            "{}: {}".format(APPLICATION_TITLE, save_file), curses.A_REVERSE)
    stdscr.chgat(-1, curses.A_REVERSE)

    status_window = curses.newwin(1, WINDOW_STATUS_WIDTH, curses.LINES - 1, 0)

    container_window = curses.newwin(curses.LINES - 2, curses.COLS, 1, 0)
    container_window.box()
    main_window = container_window.subwin(
            curses.LINES - WINDOW_MAIN_OFFSET_Y,
            curses.COLS - WINDOW_MAIN_OFFSET_X,
            WINDOW_MAIN_Y,
            WINDOW_MAIN_X)

    return WindowManager(stdscr, container_window, main_window, status_window)


def main(stdscr, save_file):
    curses.curs_set(0)

    init_colors()

    window_manager = create_windows(stdscr, save_file)
    try:
        with open(save_file, 'r') as level_definition_file:
            scene = dill.load(level_definition_file)
    except IOError:
        scene = collections.defaultdict(lambda: collections.defaultdict(list))
    global_state_manager = GlobalStateManager(window_manager, scene, save_file)

    global_state_manager.recompose_main_window()
    window_manager.redraw_all()

    while True:
        ch = chr(stdscr.getch())
        if ch not in KEYS:
            continue

        # See GlobalStateManager's docstring for more info on this.
        args = KEYS[ch]
        exec_method = getattr(global_state_manager, "exec_{}".format(args[0]))
        exec_method(*args[1:]) if len(args) > 1 else exec_method()

        if window_manager.is_recompose_main:
            global_state_manager.recompose_main_window()
        window_manager.redraw_queued()

if __name__ == "__main__":
    arguments = docopt.docopt(__doc__, version="Silo Level Editor v0.1")
    curses.wrapper(main, arguments['<level>'])
