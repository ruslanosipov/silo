#!/usr/bin/env python

import collections
import curses
import heapq

CURSOR = "X"
MOVEMENTS = {'h': (0, -1), 'j': (1, 0), 'k': (-1, 0), 'l': (0, 1)}
STATUS_WINDOW_WIDTH = 17
TILE_TYPES = {'wall': '#'}


class WindowManager(object):

    def __init__(self, windows):
        """Make sure parent windows are always left of child windows."""
        self.windows = windows
        self.redraw_queue = []

    def queue_redraw(self, window):
        heapq.heappush(self.redraw_queue, (self.windows.index(window), window))

    def redraw_all(self):
        for window in self.windows:
            window.noutrefresh()

    def redraw_queued(self):
        while self.redraw_queue:
            _, window = heapq.heappop(self.redraw_queue)
            window.noutrefresh()
        self.redraw_queue = []


class Tile(object):

    def __init__(self, tile_type):
        try:
            self.char = TILE_TYPES[tile_type]
        except KeyError:
            raise ValueError(
                    "Tried to init unknown tile type: {}".format(tile_type))


def main(stdscr):
    curses.curs_set(0)

    WINDOW_HEIGHT = curses.LINES - 6
    WINDOW_WIDTH = curses.COLS - 4
    WINDOW_Y = 3
    WINDOW_X = 2

    cursor_y = (WINDOW_HEIGHT - WINDOW_Y) / 2
    cursor_x = (WINDOW_WIDTH - WINDOW_X) / 2

    if curses.has_colors():
        curses.start_color()

    curses.init_pair(1, curses.COLOR_RED, curses.COLOR_BLACK)
    curses.init_pair(2, curses.COLOR_GREEN, curses.COLOR_BLACK)
    curses.init_pair(3, curses.COLOR_BLUE, curses.COLOR_BLACK)
    curses.init_pair(4, curses.COLOR_BLACK, curses.COLOR_WHITE)

    stdscr.addstr("SILO LEVEL EDITOR", curses.A_REVERSE)
    stdscr.chgat(-1, curses.A_REVERSE)

    status_window = curses.newwin(1, STATUS_WINDOW_WIDTH, curses.LINES - 1, 0)
    bindings_window = curses.newwin(
            1, curses.COLS -STATUS_WINDOW_WIDTH,
            curses.LINES - 1, STATUS_WINDOW_WIDTH)
    bindings_window.addstr(0, 0, (
            "Use 'hjkl' to move, insert, append, "
            "x to remove, X for remove mode, Quit."))
    bindings_window.chgat(0, 5, 4, curses.A_BOLD | curses.color_pair(2))
    bindings_window.chgat(0, 20, 1, curses.A_BOLD | curses.color_pair(2))
    bindings_window.chgat(0, 28, 1, curses.A_BOLD | curses.color_pair(2))
    bindings_window.chgat(0, 36, 1, curses.A_BOLD | curses.color_pair(2))
    bindings_window.chgat(0, 49, 1, curses.A_BOLD | curses.color_pair(2))
    bindings_window.chgat(0, 68, 1, curses.A_BOLD | curses.color_pair(1))

    container_window = curses.newwin(curses.LINES - 2, curses.COLS, 1, 0)
    main_window = container_window.subwin(
        WINDOW_HEIGHT, WINDOW_WIDTH, WINDOW_Y, WINDOW_X)
    main_window.addstr(cursor_y, cursor_x, CURSOR, curses.color_pair(3))
    container_window.box()

    window_manager = WindowManager(
        [stdscr, container_window, main_window, status_window, bindings_window])

    window_manager.redraw_all()
    curses.doupdate()

    scene = collections.defaultdict(lambda: collections.defaultdict(list))

    is_append_mode = False
    is_refresh_main = False
    is_remove_mode = False
    tile_to_append = None

    while True:
        ch = chr(stdscr.getch())

        if ch in 'hjkl':
            dy, dx = MOVEMENTS[ch]
            cursor_y += dy
            cursor_x += dx
            if is_append_mode:
                scene[cursor_y][cursor_x].append(tile_to_append)
            if is_remove_mode:
                try:
                    scene[cursor_y][cursor_x].pop()
                except IndexError:
                    pass
                if not scene[cursor_y][cursor_x]:
                    del scene[cursor_y][cursor_x]
            is_refresh_main = True
        elif ch == 'i':
            scene[cursor_y][cursor_x].append(Tile('wall'))
        elif ord(ch) == 27 \
                or ch == 'a' and is_append_mode \
                or ch == 'X' and is_remove_mode:
            is_append_mode = False
            if is_remove_mode:
                is_refresh_main = True
                is_remove_mode = False
            status_window.clear()
            window_manager.queue_redraw(status_window)
        elif ch == 'a':
            tile_to_append = Tile('wall')
            scene[cursor_y][cursor_x].append(tile_to_append)
            is_append_mode = True
            is_remove_mode = False
            status_window.clear()
            status_window.addstr(0, 0, "-- APPEND ({}) --".format(
                    tile_to_append.char))
            window_manager.queue_redraw(status_window)
        elif ch == 'x':
            try:
                scene[cursor_y][cursor_x].pop()
            except IndexError:
                pass
            if not scene[cursor_y][cursor_x]:
                del scene[cursor_y][cursor_x]
        elif ch == 'X':
            is_remove_mode = True
            is_append_mode = False
            try:
                scene[cursor_y][cursor_x].pop()
            except IndexError:
                pass
            if not scene[cursor_y][cursor_x]:
                del scene[cursor_y][cursor_x]
            status_window.clear()
            status_window.addstr(0, 0, "-- REMOVE --")
            window_manager.queue_redraw(status_window)

            is_refresh_main = True
        elif ch.lower() == 'q':
            break

        if is_refresh_main:
            main_window.clear()
            for y in scene:
                for x in scene[y]:
                    if len(scene[y][x]) > 1:
                        main_window.addstr(
                                y, x,
                                scene[y][x][-1].char, curses.color_pair(4))
                    else:
                        main_window.addstr(y, x, scene[y][x][-1].char)
            color_pair = 1 if is_remove_mode else 3
            main_window.addstr(
                    cursor_y, cursor_x, CURSOR, curses.color_pair(color_pair))
            window_manager.queue_redraw(main_window)
            is_refresh_main = False

        # Refresh all windows bottom up to prevent flickering.
        window_manager.redraw_queued()
        curses.doupdate()

if __name__ == "__main__":
    curses.wrapper(main)
